Claro, posso ajudá-lo a implementar um analisador semântico em Java para a gramática fornecida. Vou criar uma estrutura básica que você pode expandir conforme necessário. O analisador semântico realizará as seguintes tarefas principais:

1. **Análise Sintática**: Percorrerá o código-fonte de acordo com as regras da gramática.
2. **Tabela de Símbolos**: Gerenciará a tabela de símbolos para verificar declarações e usos de identificadores.
3. **Verificações Semânticas**: Implementará as ações semânticas, como verificação de tipos, compatibilidade de operações e regras específicas da linguagem.

Vou fornecer uma implementação básica usando análise sintática descendente recursiva. Note que, para um projeto real, pode ser mais eficiente usar ferramentas como ANTLR ou JavaCC. No entanto, para fins educacionais, construiremos o analisador manualmente.

---

### **Estrutura do Projeto**

- **Classe Principal**: `SemanticAnalyzer`
- **Analisador Léxico**: `Lexer` (simplificado para este exemplo)
- **Analisador Sintático/Semântico**: `Parser`
- **Tabela de Símbolos**: `SymbolTable`
- **Símbolo**: `Symbol`
- **Tipos de Dados**: Enum `Type`
- **Tokens**: Enum `TokenType`, Classe `Token`

---

### **Implementação**

#### **1. Definir os Tipos de Dados e Tokens**

```java
// Type.java
public enum Type {
    INTEGER,
    REAL,
    BOOLEAN, // Para valores lógicos
    STRING,  // Para literais
    UNDEFINED
}

// TokenType.java
public enum TokenType {
    // Palavras-chave
    APP, VAR, INIT, RETURN, INTEGER, REAL, IF, THEN, ELSE, END,
    REPEAT, UNTIL, READ, WRITE,
    // Operadores
    ASSIGN, PLUS, MINUS, TIMES, DIVIDE, EQUAL, NOT_EQUAL,
    GREATER, GREATER_EQUAL, LESS, LESS_EQUAL,
    AND, OR, NOT,
    // Símbolos
    SEMICOLON, COMMA, LPAREN, RPAREN, LBRACE, RBRACE,
    // Literais
    IDENTIFIER, INTEGER_CONST, FLOAT_CONST, STRING_LITERAL,
    // Fim de arquivo
    EOF,
    // Outros
    ERROR
}
```

#### **2. Criar a Classe Token**

```java
// Token.java
public class Token {
    public TokenType type;
    public String lexeme;
    public int line;

    public Token(TokenType type, String lexeme, int line) {
        this.type = type;
        this.lexeme = lexeme;
        this.line = line;
    }
}
```

#### **3. Implementar o Analisador Léxico Simplificado**

Para simplificar, vou implementar um analisador léxico básico que reconhece alguns tokens necessários.

```java
// Lexer.java
import java.util.*;

public class Lexer {
    private String source;
    private int pos;
    private int line;
    private char currentChar;

    private static final Set<String> keywords = new HashSet<>(Arrays.asList(
        "app", "var", "init", "return", "integer", "real", "if", "then",
        "else", "end", "repeat", "until", "read", "write"
    ));

    public Lexer(String source) {
        this.source = source;
        this.pos = 0;
        this.line = 1;
        this.currentChar = source.length() > 0 ? source.charAt(0) : '\0';
    }

    private void advance() {
        pos++;
        if (pos >= source.length()) {
            currentChar = '\0'; // EOF
        } else {
            currentChar = source.charAt(pos);
        }
    }

    private void skipWhitespace() {
        while (Character.isWhitespace(currentChar)) {
            if (currentChar == '\n') line++;
            advance();
        }
    }

    private Token number() {
        StringBuilder result = new StringBuilder();
        while (Character.isDigit(currentChar)) {
            result.append(currentChar);
            advance();
        }
        if (currentChar == '.') {
            result.append(currentChar);
            advance();
            while (Character.isDigit(currentChar)) {
                result.append(currentChar);
                advance();
            }
            return new Token(TokenType.FLOAT_CONST, result.toString(), line);
        } else {
            return new Token(TokenType.INTEGER_CONST, result.toString(), line);
        }
    }

    private Token identifier() {
        StringBuilder result = new StringBuilder();
        if (currentChar == '_') {
            result.append(currentChar);
            advance();
        }
        while (Character.isLetterOrDigit(currentChar) || currentChar == '_') {
            result.append(currentChar);
            advance();
        }
        String lexeme = result.toString();
        if (keywords.contains(lexeme)) {
            return new Token(TokenType.valueOf(lexeme.toUpperCase()), lexeme, line);
        } else {
            return new Token(TokenType.IDENTIFIER, lexeme, line);
        }
    }

    private void skipComment() {
        while (currentChar != '\n' && currentChar != '\0') {
            advance();
        }
    }

    public Token getNextToken() {
        while (currentChar != '\0') {
            if (Character.isWhitespace(currentChar)) {
                skipWhitespace();
                continue;
            }
            if (currentChar == '%') {
                skipComment();
                continue;
            }
            if (Character.isLetter(currentChar) || currentChar == '_') {
                return identifier();
            }
            if (Character.isDigit(currentChar)) {
                return number();
            }
            switch (currentChar) {
                case ';':
                    advance();
                    return new Token(TokenType.SEMICOLON, ";", line);
                case ',':
                    advance();
                    return new Token(TokenType.COMMA, ",", line);
                case '(':
                    advance();
                    return new Token(TokenType.LPAREN, "(", line);
                case ')':
                    advance();
                    return new Token(TokenType.RPAREN, ")", line);
                case '{':
                    advance();
                    return new Token(TokenType.LBRACE, "{", line);
                case '}':
                    advance();
                    return new Token(TokenType.RBRACE, "}", line);
                case '+':
                    advance();
                    return new Token(TokenType.PLUS, "+", line);
                case '-':
                    advance();
                    return new Token(TokenType.MINUS, "-", line);
                case '*':
                    advance();
                    return new Token(TokenType.TIMES, "*", line);
                case '/':
                    advance();
                    return new Token(TokenType.DIVIDE, "/", line);
                case '=':
                    advance();
                    if (currentChar == '=') {
                        advance();
                        return new Token(TokenType.EQUAL, "==", line);
                    } else {
                        return new Token(TokenType.ASSIGN, "=", line);
                    }
                case '!':
                    advance();
                    if (currentChar == '=') {
                        advance();
                        return new Token(TokenType.NOT_EQUAL, "!=", line);
                    } else {
                        return new Token(TokenType.NOT, "!", line);
                    }
                case '>':
                    advance();
                    if (currentChar == '=') {
                        advance();
                        return new Token(TokenType.GREATER_EQUAL, ">=", line);
                    } else {
                        return new Token(TokenType.GREATER, ">", line);
                    }
                case '<':
                    advance();
                    if (currentChar == '=') {
                        advance();
                        return new Token(TokenType.LESS_EQUAL, "<=", line);
                    } else {
                        return new Token(TokenType.LESS, "<", line);
                    }
                case '&':
                    advance();
                    if (currentChar == '&') {
                        advance();
                        return new Token(TokenType.AND, "&&", line);
                    } else {
                        return new Token(TokenType.ERROR, "&", line);
                    }
                case '|':
                    advance();
                    if (currentChar == '|') {
                        advance();
                        return new Token(TokenType.OR, "||", line);
                    } else {
                        return new Token(TokenType.ERROR, "|", line);
                    }
                case '"':
                    return stringLiteral();
                default:
                    char invalidChar = currentChar;
                    advance();
                    return new Token(TokenType.ERROR, String.valueOf(invalidChar), line);
            }
        }
        return new Token(TokenType.EOF, "", line);
    }

    private Token stringLiteral() {
        StringBuilder result = new StringBuilder();
        advance(); // skip initial "
        while (currentChar != '"' && currentChar != '\0' && currentChar != '\n') {
            result.append(currentChar);
            advance();
        }
        if (currentChar == '"') {
            advance();
            return new Token(TokenType.STRING_LITERAL, result.toString(), line);
        } else {
            return new Token(TokenType.ERROR, result.toString(), line);
        }
    }
}
```

#### **4. Implementar a Tabela de Símbolos**

```java
// Symbol.java
public class Symbol {
    public String name;
    public Type type;

    public Symbol(String name, Type type) {
        this.name = name;
        this.type = type;
    }
}

// SymbolTable.java
import java.util.HashMap;
import java.util.Map;

public class SymbolTable {
    private Map<String, Symbol> symbols = new HashMap<>();

    public void declare(String name, Type type, int line) throws Exception {
        if (symbols.containsKey(name)) {
            throw new Exception("Erro na linha " + line + ": Identificador '" + name + "' já declarado.");
        }
        symbols.put(name, new Symbol(name, type));
    }

    public Symbol lookup(String name) {
        return symbols.get(name);
    }
}
```

#### **5. Implementar o Analisador Sintático e Semântico**

```java
// Parser.java
public class Parser {
    private Lexer lexer;
    private Token currentToken;
    private SymbolTable symbolTable = new SymbolTable();

    public Parser(Lexer lexer) throws Exception {
        this.lexer = lexer;
        this.currentToken = lexer.getNextToken();
    }

    private void eat(TokenType type) throws Exception {
        if (currentToken.type == type) {
            currentToken = lexer.getNextToken();
        } else {
            throw new Exception("Erro na linha " + currentToken.line + ": Esperado '" + type + "' mas encontrado '" + currentToken.lexeme + "'.");
        }
    }

    public void parse() throws Exception {
        program();
        System.out.println("Análise concluída com sucesso!");
    }

    // Implementação das regras gramaticais com ações semânticas
    private void program() throws Exception {
        eat(TokenType.APP);
        eat(TokenType.IDENTIFIER); // Nome do programa
        body();
    }

    private void body() throws Exception {
        if (currentToken.type == TokenType.VAR) {
            eat(TokenType.VAR);
            declList();
        }
        eat(TokenType.INIT);
        stmtList();
        eat(TokenType.RETURN);
    }

    private void declList() throws Exception {
        decl();
        while (currentToken.type == TokenType.SEMICOLON) {
            eat(TokenType.SEMICOLON);
            decl();
        }
    }

    private void decl() throws Exception {
        Type type = type();
        identList(type);
    }

    private Type type() throws Exception {
        if (currentToken.type == TokenType.INTEGER) {
            eat(TokenType.INTEGER);
            return Type.INTEGER;
        } else if (currentToken.type == TokenType.REAL) {
            eat(TokenType.REAL);
            return Type.REAL;
        } else {
            throw new Exception("Erro na linha " + currentToken.line + ": Tipo inválido '" + currentToken.lexeme + "'.");
        }
    }

    private void identList(Type type) throws Exception {
        if (currentToken.type == TokenType.IDENTIFIER) {
            String name = currentToken.lexeme;
            eat(TokenType.IDENTIFIER);
            // Ação Semântica: Declarar variável
            symbolTable.declare(name, type, currentToken.line);
        } else {
            throw new Exception("Erro na linha " + currentToken.line + ": Identificador esperado.");
        }
        while (currentToken.type == TokenType.COMMA) {
            eat(TokenType.COMMA);
            if (currentToken.type == TokenType.IDENTIFIER) {
                String name = currentToken.lexeme;
                eat(TokenType.IDENTIFIER);
                // Ação Semântica: Declarar variável
                symbolTable.declare(name, type, currentToken.line);
            } else {
                throw new Exception("Erro na linha " + currentToken.line + ": Identificador esperado após ','.");
            }
        }
    }

    private void stmtList() throws Exception {
        stmt();
        while (currentToken.type == TokenType.SEMICOLON) {
            eat(TokenType.SEMICOLON);
            stmt();
        }
    }

    private void stmt() throws Exception {
        switch (currentToken.type) {
            case IDENTIFIER:
                assignStmt();
                break;
            case IF:
                ifStmt();
                break;
            case REPEAT:
                repeatStmt();
                break;
            case READ:
                readStmt();
                break;
            case WRITE:
                writeStmt();
                break;
            default:
                throw new Exception("Erro na linha " + currentToken.line + ": Comando inválido '" + currentToken.lexeme + "'.");
        }
    }

    private void assignStmt() throws Exception {
        String name = currentToken.lexeme;
        eat(TokenType.IDENTIFIER);
        // Ação Semântica: Verificar declaração
        Symbol var = symbolTable.lookup(name);
        if (var == null) {
            throw new Exception("Erro na linha " + currentToken.line + ": Variável '" + name + "' não declarada.");
        }
        eat(TokenType.ASSIGN);
        Type exprType = simpleExpr();
        // Ação Semântica: Verificação de tipos
        if (!isAssignmentCompatible(var.type, exprType)) {
            throw new Exception("Erro na linha " + currentToken.line + ": Incompatibilidade de tipos na atribuição para '" + name + "'.");
        }
    }

    private boolean isAssignmentCompatible(Type varType, Type exprType) {
        if (varType == Type.REAL && (exprType == Type.INTEGER || exprType == Type.REAL)) {
            return true;
        }
        return varType == exprType;
    }

    private void ifStmt() throws Exception {
        eat(TokenType.IF);
        Type condType = condition();
        // Ação Semântica: Verificar se condição é lógica
        if (condType != Type.BOOLEAN) {
            throw new Exception("Erro na linha " + currentToken.line + ": A condição do 'if' deve ser lógica.");
        }
        eat(TokenType.THEN);
        stmtList();
        if (currentToken.type == TokenType.ELSE) {
            eat(TokenType.ELSE);
            stmtList();
        }
        eat(TokenType.END);
    }

    private void repeatStmt() throws Exception {
        eat(TokenType.REPEAT);
        stmtList();
        stmtSuffix();
    }

    private void stmtSuffix() throws Exception {
        eat(TokenType.UNTIL);
        Type condType = condition();
        // Ação Semântica: Verificar se condição é lógica
        if (condType != Type.BOOLEAN) {
            throw new Exception("Erro na linha " + currentToken.line + ": A condição do 'until' deve ser lógica.");
        }
    }

    private void readStmt() throws Exception {
        eat(TokenType.READ);
        eat(TokenType.LPAREN);
        String name = currentToken.lexeme;
        eat(TokenType.IDENTIFIER);
        // Ação Semântica: Verificar declaração
        Symbol var = symbolTable.lookup(name);
        if (var == null) {
            throw new Exception("Erro na linha " + currentToken.line + ": Variável '" + name + "' não declarada.");
        }
        eat(TokenType.RPAREN);
    }

    private void writeStmt() throws Exception {
        eat(TokenType.WRITE);
        eat(TokenType.LPAREN);
        Type exprType = writable();
        eat(TokenType.RPAREN);
    }

    private Type writable() throws Exception {
        if (currentToken.type == TokenType.STRING_LITERAL) {
            eat(TokenType.STRING_LITERAL);
            return Type.STRING;
        } else {
            return simpleExpr();
        }
    }

    private Type condition() throws Exception {
        return expression();
    }

    private Type expression() throws Exception {
        Type left = simpleExpr();
        if (isRelOp(currentToken.type)) {
            TokenType op = currentToken.type;
            eat(currentToken.type);
            Type right = simpleExpr();
            // Ação Semântica: Verificar compatibilidade de tipos
            if (!isTypeCompatible(left, right)) {
                throw new Exception("Erro na linha " + currentToken.line + ": Tipos incompatíveis na expressão.");
            }
            return Type.BOOLEAN;
        }
        return left;
    }

    private boolean isRelOp(TokenType type) {
        return type == TokenType.EQUAL || type == TokenType.NOT_EQUAL ||
               type == TokenType.GREATER || type == TokenType.GREATER_EQUAL ||
               type == TokenType.LESS || type == TokenType.LESS_EQUAL;
    }

    private Type simpleExpr() throws Exception {
        Type termType = term();
        Type exprType = simpleExprPrime(termType);
        return exprType;
    }

    private Type simpleExprPrime(Type inheritedType) throws Exception {
        if (isAddOp(currentToken.type)) {
            TokenType op = currentToken.type;
            eat(currentToken.type);
            Type termType = term();
            // Ação Semântica: Verificar tipos
            Type resultType = getResultType(inheritedType, termType, op);
            return simpleExprPrime(resultType);
        }
        return inheritedType;
    }

    private boolean isAddOp(TokenType type) {
        return type == TokenType.PLUS || type == TokenType.MINUS || type == TokenType.OR;
    }

    private Type term() throws Exception {
        Type factorType = factorA();
        Type termType = termPrime(factorType);
        return termType;
    }

    private Type termPrime(Type inheritedType) throws Exception {
        if (isMulOp(currentToken.type)) {
            TokenType op = currentToken.type;
            eat(currentToken.type);
            Type factorType = factorA();
            // Ação Semântica: Verificar tipos
            Type resultType = getResultType(inheritedType, factorType, op);
            return termPrime(resultType);
        }
        return inheritedType;
    }

    private boolean isMulOp(TokenType type) {
        return type == TokenType.TIMES || type == TokenType.DIVIDE || type == TokenType.AND;
    }

    private Type factorA() throws Exception {
        if (currentToken.type == TokenType.NOT) {
            eat(TokenType.NOT);
            Type factorType = factor();
            if (factorType != Type.BOOLEAN) {
                throw new Exception("Erro na linha " + currentToken.line + ": Operador '!' aplicado a um não booleano.");
            }
            return Type.BOOLEAN;
        } else if (currentToken.type == TokenType.MINUS) {
            eat(TokenType.MINUS);
            Type factorType = factor();
            if (factorType != Type.INTEGER && factorType != Type.REAL) {
                throw new Exception("Erro na linha " + currentToken.line + ": Operador '-' aplicado a um não numérico.");
            }
            return factorType;
        } else {
            return factor();
        }
    }

    private Type factor() throws Exception {
        switch (currentToken.type) {
            case IDENTIFIER:
                String name = currentToken.lexeme;
                eat(TokenType.IDENTIFIER);
                // Ação Semântica: Verificar declaração
                Symbol var = symbolTable.lookup(name);
                if (var == null) {
                    throw new Exception("Erro na linha " + currentToken.line + ": Variável '" + name + "' não declarada.");
                }
                return var.type;
            case INTEGER_CONST:
                eat(TokenType.INTEGER_CONST);
                return Type.INTEGER;
            case FLOAT_CONST:
                eat(TokenType.FLOAT_CONST);
                return Type.REAL;
            case LPAREN:
                eat(TokenType.LPAREN);
                Type exprType = expression();
                eat(TokenType.RPAREN);
                return exprType;
            default:
                throw new Exception("Erro na linha " + currentToken.line + ": Fator inválido.");
        }
    }

    private Type getResultType(Type left, Type right, TokenType op) throws Exception {
        if (op == TokenType.PLUS || op == TokenType.MINUS || op == TokenType.TIMES || op == TokenType.DIVIDE) {
            if ((left == Type.INTEGER || left == Type.REAL) && (right == Type.INTEGER || right == Type.REAL)) {
                if (left == Type.REAL || right == Type.REAL) {
                    return Type.REAL;
                } else {
                    return Type.INTEGER;
                }
            } else {
                throw new Exception("Erro na linha " + currentToken.line + ": Operação aritmética com operandos não numéricos.");
            }
        } else if (op == TokenType.OR || op == TokenType.AND) {
            if (left == Type.BOOLEAN && right == Type.BOOLEAN) {
                return Type.BOOLEAN;
            } else {
                throw new Exception("Erro na linha " + currentToken.line + ": Operação lógica com operandos não booleanos.");
            }
        } else {
            throw new Exception("Erro na linha " + currentToken.line + ": Operador desconhecido.");
        }
    }

    private boolean isTypeCompatible(Type left, Type right) {
        return left == right || (left == Type.REAL && right == Type.INTEGER) || (left == Type.INTEGER && right == Type.REAL);
    }
}
```

#### **6. Classe Principal**

```java
// SemanticAnalyzer.java
public class SemanticAnalyzer {
    public static void main(String[] args) {
        String sourceCode = """
            app myProgram
            var
                integer x, y;
                real z
            init
                x = 10;
                y = 20;
                z = x + y * 2.5;
                if x > y then
                    write("x is greater");
                else
                    write("y is greater");
                end
            return
            """;

        Lexer lexer = new Lexer(sourceCode);
        try {
            Parser parser = new Parser(lexer);
            parser.parse();
        } catch (Exception e) {
            System.err.println(e.getMessage());
        }
    }
}
```

---

### **Explicação do Código**

- **Lexer**: Responsável por tokenizar o código-fonte. Ele reconhece palavras-chave, identificadores, números, operadores e símbolos.
- **SymbolTable**: Armazena informações sobre os identificadores declarados, incluindo seus tipos.
- **Parser**: Implementa as regras gramaticais e realiza as ações semânticas. Cada método corresponde a uma regra da gramática.
    - **Ações Semânticas**:
        - **Declaração de Variáveis**: Ao reconhecer uma declaração, adiciona o identificador à tabela de símbolos.
        - **Verificação de Uso**: Antes de usar um identificador, verifica se ele foi declarado.
        - **Verificação de Tipos**: Durante operações e atribuições, verifica se os tipos são compatíveis conforme as regras especificadas.
        - **Condições**: Verifica se as expressões em condições retornam valores lógicos.
- **Tipos**: Utiliza o enum `Type` para representar os tipos de dados da linguagem.
- **Análise de Expressões**: Implementa a análise de expressões com precedência de operadores e realiza verificações de tipo durante a avaliação.

---

### **Testando o Analisador**

O código de exemplo fornecido na classe `SemanticAnalyzer` pode ser usado para testar o analisador. Você pode modificar o `sourceCode` para incluir diferentes cenários e verificar se o analisador semântico está detectando erros corretamente.

---

### **Considerações Finais**

- **Extensibilidade**: O código fornecido é uma base que pode ser expandida para suportar mais recursos da linguagem.
- **Erros Semânticos**: O analisador lança exceções quando detecta erros semânticos, informando a linha e a natureza do erro.
- **Comentários**: O analisador léxico ignora linhas que começam com `%`, conforme especificado.
- **Case-Sensitive**: Os identificadores são tratados como case-sensitive.

Espero que este código atenda às suas necessidades. Sinta-se à vontade para ajustar e expandir conforme necessário para o seu compilador.