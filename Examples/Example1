// SemanticAnalysis.java
package semantic;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import lexical.*;
import syntactic.SyntacticAnalysis;
import syntactic.SyntaticException;

public class SemanticAnalysis extends SyntacticAnalysis {

    private Map<String, TokenType> symbolTable = new HashMap<>();
    private TokenType currentType;

    public SemanticAnalysis(String filePath) throws IOException {
        super(filePath);
    }

    // Armazenar a tabela de tipos de variáveis para verificação de tipos
    private Map<String, TokenType> variableTypes = new HashMap<>();

    @Override
    protected void identList() throws IOException, SyntaticException {
        switch (currentToken.getTag()) {
            case IDENTIFIER:
                String varName = currentToken.getLexeme();
                // Verifica se a variável já foi declarada (sensível a maiúsculas/minúsculas)
                if (symbolTable.containsKey(varName)) {
                    throw new SyntaticException("Erro Semântico: Variável '" + varName + "' já declarada. Linha: " + lex.getLine());
                }
                eat(TokenType.IDENTIFIER);
                // Adiciona a variável na tabela de símbolos com o tipo atual
                symbolTable.put(varName, currentType);
                variableTypes.put(varName, currentType);
                if (currentToken.getTag() == TokenType.COMMA) {
                    eat(TokenType.COMMA);
                    identList();
                }
                break;
            default:
                error();
                break;
        }
    }

    @Override
    protected void type() throws IOException, SyntaticException {
        switch (currentToken.getTag()) {
            case INTEGER:
                currentType = TokenType.INTEGER;
                eat(TokenType.INTEGER);
                break;
            case REAL:
                currentType = TokenType.REAL;
                eat(TokenType.REAL);
                break;
            default:
                error();
                break;
        }
    }

    @Override
    protected void factor() throws IOException, SyntaticException {
        if (currentToken.getTag() == TokenType.IDENTIFIER) {
            String varName = currentToken.getLexeme();
            // Verifica se a variável foi declarada
            if (!symbolTable.containsKey(varName)) {
                throw new SyntaticException("Erro Semântico: Variável '" + varName + "' não declarada. Linha: " + lex.getLine());
            }
            eat(TokenType.IDENTIFIER);
        } else if (currentToken.getTag() == TokenType.OPEN_PAR) {
            eat(TokenType.OPEN_PAR);
            expression();
            eat(TokenType.CLOSE_PAR);
        } else {
            this.constant();
        }
    }

    @Override
    protected void assignStmt() throws IOException, SyntaticException {
        String varName = currentToken.getLexeme();
        // Verifica se a variável foi declarada
        if (!symbolTable.containsKey(varName)) {
            throw new SyntaticException("Erro Semântico: Variável '" + varName + "' não declarada. Linha: " + lex.getLine());
        }
        TokenType varType = variableTypes.get(varName);
        eat(TokenType.IDENTIFIER);
        eat(TokenType.DOT_ASSIGN);
        TokenType exprType = this.simpleExpr();
        // Verifica compatibilidade de tipos
        if (!isTypeCompatible(varType, exprType)) {
            throw new SyntaticException("Erro Semântico: Atribuição incompatível para a variável '" + varName + "'. Esperado '" + varType.name() + "', encontrado '" + exprType.name() + "'. Linha: " + lex.getLine());
        }
    }

    private boolean isTypeCompatible(TokenType varType, TokenType exprType) {
        if (varType == exprType) {
            return true;
        }
        // Permitir atribuição de inteiro a real
        if (varType == TokenType.REAL && exprType == TokenType.INTEGER) {
            return true;
        }
        // Não permitir atribuição de real a inteiro
        return false;
    }

    @Override
    protected TokenType simpleExpr() throws IOException, SyntaticException {
        TokenType termType = this.term();
        return this.simpleExpr_(termType);
    }

    protected TokenType simpleExpr_(TokenType inheritedType) throws IOException, SyntaticException {
        if (currentToken.getTag() == TokenType.PLUS ||
                currentToken.getTag() == TokenType.MINUS ||
                currentToken.getTag() == TokenType.OR) {
            TokenType op = this.addop();
            TokenType termType = this.term();
            TokenType resultType = getResultType(inheritedType, termType, op);
            return this.simpleExpr_(resultType);
        }
        return inheritedType;
    }

    @Override
    protected TokenType term() throws IOException, SyntaticException {
        TokenType factorType = factor_a();
        return term_(factorType);
    }

    protected TokenType term_(TokenType inheritedType) throws IOException, SyntaticException {
        if (currentToken.getTag() == TokenType.MULTIPLY ||
                currentToken.getTag() == TokenType.DIVIDE ||
                currentToken.getTag() == TokenType.AND) {
            TokenType op = mulop();
            TokenType factorType = factor_a();
            TokenType resultType = getResultType(inheritedType, factorType, op);
            return term_(resultType);
        }
        return inheritedType;
    }

    protected TokenType factor_a() throws IOException, SyntaticException {
        if (currentToken.getTag() == TokenType.NOT) {
            eat(TokenType.NOT);
            TokenType factorType = factor();
            // NOT é uma operação lógica, o operando deve ser inteiro (booleano)
            if (factorType != TokenType.INTEGER) {
                throw new SyntaticException("Erro Semântico: Operador '!' requer operando inteiro (booleano). Linha: " + lex.getLine());
            }
            return TokenType.INTEGER;
        } else if (currentToken.getTag() == TokenType.MINUS) {
            eat(TokenType.MINUS);
            return factor();
        } else {
            return factor();
        }
    }

    @Override
    protected TokenType factor() throws IOException, SyntaticException {
        if (currentToken.getTag() == TokenType.IDENTIFIER) {
            String varName = currentToken.getLexeme();
            // Verifica se a variável foi declarada
            if (!symbolTable.containsKey(varName)) {
                throw new SyntaticException("Erro Semântico: Variável '" + varName + "' não declarada. Linha: " + lex.getLine());
            }
            eat(TokenType.IDENTIFIER);
            return variableTypes.get(varName);
        } else if (currentToken.getTag() == TokenType.OPEN_PAR) {
            eat(TokenType.OPEN_PAR);
            TokenType exprType = expression();
            eat(TokenType.CLOSE_PAR);
            return exprType;
        } else {
            return this.constant();
        }
    }

    @Override
    protected TokenType constant() throws IOException, SyntaticException {
        switch (currentToken.getTag()) {
            case INTEGER_CONST:
                eat(TokenType.INTEGER_CONST);
                return TokenType.INTEGER;
            case FLOAT_CONST:
                eat(TokenType.FLOAT_CONST);
                return TokenType.REAL;
            default:
                error();
                return null;
        }
    }

    @Override
    protected TokenType expression() throws IOException, SyntaticException {
        TokenType simpleExprType = this.simpleExpr();
        if (currentToken.getTag() == TokenType.ASSIGN
                || currentToken.getTag() == TokenType.GREATER
                || currentToken.getTag() == TokenType.GREATER_EQUAL
                || currentToken.getTag() == TokenType.LESS
                || currentToken.getTag() == TokenType.LESS_EQUAL
                || currentToken.getTag() == TokenType.NOT_EQUAL) {
            TokenType op = this.relop();
            TokenType rightExprType = this.simpleExpr();
            // Verificar compatibilidade de tipos nas operações relacionais
            getResultType(simpleExprType, rightExprType, op);
            // O resultado de uma expressão relacional é inteiro (booleano)
            return TokenType.INTEGER;
        }
        return simpleExprType;
    }

    @Override
    protected TokenType addop() throws IOException, SyntaticException {
        switch (currentToken.getTag()) {
            case PLUS:
                eat(TokenType.PLUS);
                return TokenType.PLUS;
            case MINUS:
                eat(TokenType.MINUS);
                return TokenType.MINUS;
            case OR:
                eat(TokenType.OR);
                return TokenType.OR;
            default:
                error();
                return null;
        }
    }

    @Override
    protected TokenType mulop() throws IOException, SyntaticException {
        switch (currentToken.getTag()) {
            case MULTIPLY:
                eat(TokenType.MULTIPLY);
                return TokenType.MULTIPLY;
            case DIVIDE:
                eat(TokenType.DIVIDE);
                return TokenType.DIVIDE;
            case AND:
                eat(TokenType.AND);
                return TokenType.AND;
            default:
                error();
                return null;
        }
    }

    private TokenType getResultType(TokenType type1, TokenType type2, TokenType op) throws SyntaticException {
        // Operações lógicas requerem operandos inteiros (booleanos)
        if (op == TokenType.OR || op == TokenType.AND) {
            if (type1 == TokenType.INTEGER && type2 == TokenType.INTEGER) {
                return TokenType.INTEGER;
            } else {
                throw new SyntaticException("Erro Semântico: Operadores lógicos requerem operandos inteiros (booleanos). Linha: " + lex.getLine());
            }
        }

        // Operações relacionais
        if (op == TokenType.ASSIGN || op == TokenType.GREATER || op == TokenType.GREATER_EQUAL ||
            op == TokenType.LESS || op == TokenType.LESS_EQUAL || op == TokenType.NOT_EQUAL) {
            if ((type1 == TokenType.INTEGER || type1 == TokenType.REAL) &&
                (type2 == TokenType.INTEGER || type2 == TokenType.REAL)) {
                return TokenType.INTEGER; // Resultado é inteiro (booleano)
            } else {
                throw new SyntaticException("Erro Semântico: Operadores relacionais requerem operandos numéricos. Linha: " + lex.getLine());
            }
        }

        // Operações aritméticas
        if (op == TokenType.PLUS || op == TokenType.MINUS ||
            op == TokenType.MULTIPLY || op == TokenType.DIVIDE) {
            if (type1 == type2) {
                return type1;
            } else if ((type1 == TokenType.INTEGER && type2 == TokenType.REAL) ||
                       (type1 == TokenType.REAL && type2 == TokenType.INTEGER)) {
                return TokenType.REAL;
            } else {
                throw new SyntaticException("Erro Semântico: Operadores aritméticos requerem operandos numéricos. Linha: " + lex.getLine());
            }
        }

        // Operador não reconhecido
        throw new SyntaticException("Erro Semântico: Operador não reconhecido. Linha: " + lex.getLine());
    }

    @Override
    protected TokenType relop() throws IOException, SyntaticException {
        switch (currentToken.getTag()) {
            case ASSIGN:
                eat(TokenType.ASSIGN);
                return TokenType.ASSIGN;
            case GREATER:
                eat(TokenType.GREATER);
                return TokenType.GREATER;
            case GREATER_EQUAL:
                eat(TokenType.GREATER_EQUAL);
                return TokenType.GREATER_EQUAL;
            case LESS:
                eat(TokenType.LESS);
                return TokenType.LESS;
            case LESS_EQUAL:
                eat(TokenType.LESS_EQUAL);
                return TokenType.LESS_EQUAL;
            case NOT_EQUAL:
                eat(TokenType.NOT_EQUAL);
                return TokenType.NOT_EQUAL;
            default:
                error();
                return null;
        }
    }

    @Override
    protected void readStmt() throws IOException, SyntaticException {
        switch (currentToken.getTag()) {
            case READ:
                eat(TokenType.READ);
                if (currentToken.getTag() == TokenType.OPEN_PAR) {
                    eat(TokenType.OPEN_PAR);
                    String varName = currentToken.getLexeme();
                    // Verifica se a variável foi declarada
                    if (!symbolTable.containsKey(varName)) {
                        throw new SyntaticException("Erro Semântico: Variável '" + varName + "' não declarada. Linha: " + lex.getLine());
                    }
                    eat(TokenType.IDENTIFIER);
                    eat(TokenType.CLOSE_PAR);
                } else {
                    error();
                }
                break;
            default:
                error();
                break;
        }
    }

    @Override
    protected void writeStmt() throws IOException, SyntaticException {
        switch (currentToken.getTag()) {
            case WRITE:
                eat(TokenType.WRITE);
                if (currentToken.getTag() == TokenType.OPEN_PAR) {
                    eat(TokenType.OPEN_PAR);
                    writable();
                    eat(TokenType.CLOSE_PAR);
                } else {
                    error();
                }
                break;

            default:
                error();
                break;
        }
    }

    @Override
    protected void writable() throws IOException, SyntaticException {
        if (currentToken.getTag() == TokenType.LITERAL) {
            eat(TokenType.LITERAL);
        } else {
            simpleExpr();
        }
    }

    @Override
    protected void ifStmt() throws IOException, SyntaticException {
        eat(TokenType.IF);
        this.condition();
        eat(TokenType.THEN);
        stmtList();

        if (currentToken.getTag() == TokenType.END) {
            eat(TokenType.END);
        } else if (currentToken.getTag() == TokenType.ELSE) {
            eat(TokenType.ELSE);
            stmtList();
            eat(TokenType.END);
        } else {
            error();
        }
    }

    @Override
    protected void condition() throws IOException, SyntaticException {
        TokenType exprType = this.expression();
        // Verifica se a condição é do tipo inteiro (booleano)
        if (exprType != TokenType.INTEGER) {
            throw new SyntaticException("Erro Semântico: Condição deve ser uma expressão booleana. Linha: " + lex.getLine());
        }
    }

    @Override
    protected void repeatStmt() throws IOException, SyntaticException {
        switch (currentToken.getTag()) {
            case REPEAT:
                eat(TokenType.REPEAT);
                stmtList();
                stmtSuffix();
                break;
            default:
                error();
                break;
        }
    }

    @Override
    protected void stmtSuffix() throws IOException, SyntaticException {
        switch (currentToken.getTag()) {
            case UNTIL:
                eat(TokenType.UNTIL);
                condition();
                break;

            default:
                error();
                break;
        }
    }

    @Override
    protected void error() throws SyntaticException {
        throw new SyntaticException(
                "\nErro Sintático: Token " + this.currentToken.getTag().name() + " não esperado!\nLinha: " + lex.getLine() + "\n");
    }
}
